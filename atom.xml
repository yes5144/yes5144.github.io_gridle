<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yes5144.github.io/</id>
    <title>Talk is cheap. Show me the code</title>
    <updated>2019-06-27T15:56:12.105Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yes5144.github.io/"/>
    <link rel="self" href="https://yes5144.github.io//atom.xml"/>
    <subtitle>唯手熟尔</subtitle>
    <logo>https://yes5144.github.io//images/avatar.png</logo>
    <icon>https://yes5144.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Talk is cheap. Show me the code</rights>
    <entry>
        <title type="html"><![CDATA[saltstack常用操作]]></title>
        <id>https://yes5144.github.io//post/saltstack-chang-yong-cao-zuo</id>
        <link href="https://yes5144.github.io//post/saltstack-chang-yong-cao-zuo">
        </link>
        <updated>2019-06-23T04:37:32.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>saltstack采用c/s架构，角色分为master/slave，建议采用yum部署</p>
</blockquote>
<h4 id="配置minion">配置minion</h4>
<pre><code>vim  /etc/salt/minion
master: master-id
id: hostname&lt;weiyi&gt;

</code></pre>
<h4 id="管理-salt-key">管理 salt key</h4>
<pre><code>salt-key  -L
salt-key  -A
salt-key  -D
salt-key  -a &lt;ID&gt;
salt-key  -d &lt;ID&gt;
salt-key  -l acc|grep -c -v 'Accepted Keys:'
</code></pre>
<h4 id="组织主机节点">组织主机节点</h4>
<pre><code>vim  /etc/salt/master
nodegroups:
  web: 'L@192.168.204.12,192.168.204.13'
  db: 'L@192.168.204.32,192.168.204.33'
## 无需重启salt-master，保存即可生效
salt -N web test.ping
salt -N db test.ping
</code></pre>
<h4 id="模块的调用">模块的调用</h4>
<pre><code>## ping模块
salt node1 test.ping
## cmd模块
salt node2 cmd.run 'id'
salt node2 cmd.run 'curl -L http://scripts.example.com/scripts/example.sh |bash'
### 想携带参数？
salt node2 cmd.scripts salt://scripts/example.sh &quot;arg1 arg2 'arg   3'&quot;
salt node2 cmd.scripts http://scripts.example.com/scripts/example.sh &quot;arguments&quot;

## pkg模块
salt node2 pkg.install 'vsftpd,lftp'
salt node2 pkg.remove 'vsftpd,lftp'

## file.replace
salt node1 file.replace /ets/ssh/sshd_config pattern='#Port 22' repl='Port 22'

## manage
</code></pre>
<h4 id="slssalt-state">SLS(salt state)</h4>
<h4 id="grain">Grain</h4>
<pre><code>salt node1 grains.ls |wc -l
salt node1 grains.item server_type
salt node1 grains.item ip4_interfaces:eth0

</code></pre>
<h4 id="pillar">Pillar</h4>
<blockquote>
<p>Pillar和Grain的区别是什么？
Grain是在Master上面创建的，但它的取值来自于Minion，而且Grain的代码是通过调用模块saltutil.sync_grains将其同步到Minion上面执行的。在执行结果没有返回之前，Grain的值时未知的，需要根据Minion的实际环境确认。
和Grain不同的是，Pillar是在Master上定义和存储的，是为了编写sls文件时便于引用而创建的，它的变量和赋值在执行之前就已经确定好了，和Minion的状态没有关系。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python字符编码转换Unicode和str]]></title>
        <id>https://yes5144.github.io//post/python-zi-fu-bian-ma-zhuan-huan-unicode-he-str</id>
        <link href="https://yes5144.github.io//post/python-zi-fu-bian-ma-zhuan-huan-unicode-he-str">
        </link>
        <updated>2019-06-22T16:56:44.000Z</updated>
        <content type="html"><![CDATA[<p>参考链接1：https://blog.csdn.net/VictoriaW/article/details/75314737</p>
<p>参考链接2：https://blog.csdn.net/sheldonwong/article/details/86684761
Unicode和str</p>
<pre><code>## str 我们平时写的用引号括起来的字符串都是str类型的。
&gt;&gt;&gt; x = '哈哈'
&gt;&gt;&gt; x
'\xb9\xfe\xb9\xfe'
### 根据上面的打印结果，可以知道str类型的x存的其实是二进制序列，而非字符串。为什么会出现这种情况呢？我们赋给x的明明是字符串。
其实很简单，x经过了一次隐形的编码过程encode()。应该采用的是系统默认编码方案。 

## unicode 如果在引号的前面加上字符u，那么我们就得到一个unicode字符串：
&gt;&gt;&gt; x = u'哈哈'
&gt;&gt;&gt; x
u'\u54c8\u54c8'
### unicode对象保存的是字符串本身，而非二进制序列。比如程序中的unicode字符串中包含两个U+54c8字符。

### 为了避免错误，在写入文件之前，应该用utf-8或者gbk编码方案对unicode字符串编码
&gt;&gt;&gt; x = u'哈哈'
&gt;&gt;&gt; x
u'\u54c8\u54c8'
&gt;&gt;&gt; f = open('test.txt', 'w');
&gt;&gt;&gt; x = x.encode('utf-8') #unicode -&gt; str
&gt;&gt;&gt;x
'\xe5\x93\x88\xe5\x93\x88'
&gt;&gt;&gt; f.write(x)

</code></pre>
<blockquote>
<p>Unicode strings can be encoded in plain strings in a variety of ways, according to whichever encoding you choose:
Unicode字符串可以用多种方式编码为普通字符串, 依照你所选择的编码(encoding):</p>
</blockquote>
<pre><code>   1 #将Unicode转换成普通的Python字符串:&quot;编码(encode)&quot;
   2 unicodestring = u&quot;Hello world&quot;
   3 utf8string = unicodestring.encode(&quot;utf-8&quot;)
   4 asciistring = unicodestring.encode(&quot;ascii&quot;)
   5 isostring = unicodestring.encode(&quot;ISO-8859-1&quot;)
   6 utf16string = unicodestring.encode(&quot;utf-16&quot;)
   7 
   8 
   9 #将普通的Python字符串转换成Unicode: &quot;解码(decode)&quot;
  10 plainstring1 = unicode(utf8string, &quot;utf-8&quot;)
  11 plainstring2 = unicode(asciistring, &quot;ascii&quot;)
  12 plainstring3 = unicode(isostring, &quot;ISO-8859-1&quot;)
  13 plainstring4 = unicode(utf16string, &quot;utf-16&quot;)
  14 
  15 assert plainstring1==plainstring2==plainstring3==plainstring4

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python日期模块datetime]]></title>
        <id>https://yes5144.github.io//post/python-ri-qi-mo-kuai-datetime</id>
        <link href="https://yes5144.github.io//post/python-ri-qi-mo-kuai-datetime">
        </link>
        <updated>2019-06-22T16:47:38.000Z</updated>
        <content type="html"><![CDATA[<p>参考链接：https://blog.csdn.net/cmzsteven/article/details/64906245</p>
<pre><code># coding: utf8
import  os
import datetime
print(os.getcwd())
print(os.listdir())

dict_host = [
{u'connections': 2900.0, u'update_time': u'2019-06-22 15:23:32',  u'cpu_idle': 91.0231, u'load_5': 0.16, u'swap_use': 1.6046, u'opt_free': 77.2042, u'server_db': u'74', u'host_name': u'HD-WEB106', u'mem_use': 72.5713, u'db_qps': 0.0, u'id': 8302},
{u'connections': 2888.0, u'update_time': u'2019-06-23 00:32:12',  u'cpu_idle': 91.2088, u'load_5': 0.28, u'swap_use': 1.6081, u'opt_free': 70.3049, u'server_db': u'73', u'host_name': u'HD-WEB110', u'mem_use': 72.1353, u'db_qps': 0.0, u'id': 8319},
{u'connections': 10260.0, u'update_time': u'2019-06-22 17:39:33',  u'cpu_idle': 84.0146, u'load_5': 0.53, u'swap_use': 0.0, u'opt_free': 91.1708, u'server_db': u'86', u'host_name': u'HD-WEB167', u'mem_use': 50.3518, u'db_qps': 0.0, u'id': 8445},
]
# now = datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)
now = datetime.datetime.now()
last_hour = (datetime.datetime.now() + datetime.timedelta(hours = -0.4)).strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)
print (type(now),'\t',now)
print (type(last_hour),'\t',last_hour)

print(&quot;#-&quot;*10)
for i in dict_host:
    if i[&quot;update_time&quot;] &gt; last_hour:
        print(type(i[&quot;update_time&quot;]),i[&quot;update_time&quot;])
    else:
        print (&quot;资源信息已过期&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python生成器]]></title>
        <id>https://yes5144.github.io//post/python-sheng-cheng-qi</id>
        <link href="https://yes5144.github.io//post/python-sheng-cheng-qi">
        </link>
        <updated>2019-06-22T08:23:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>创建生成器的一种方法是利用yield关键字，他的作用和return类似，解释器在函数中遇到yield后会立即返回响应的值。但是yield跟return的最大的不同是，在下次调用这个函数的时候不会从头开始执行，而是会从上次yield返回后的下一句开始执行，并且这时候函数的上下文，简单来说就是各变量的值，也是和上次yield返回的时候是一致的。
形象的说，普通使用return的函数每次执行就像是一条线段，从一个端点到另一个端点，但是使用了yield的函数每次执行更像是一个圆，从一个起点开始在固定位置返回后继续绕圈执行。同时关键的一点事，任何使用yield的函数返回值就会成为一个生成器对象。</p>
</blockquote>
<pre><code>def  my_range(end):
    i = 0
    while i &lt; end:
        yield i   ## 这里返回 i
        i += 1

## print 函数返回对象的类型：
g = my_range(10)
print(type(g))
</code></pre>
<h4 id="生成器推导式">生成器推导式</h4>
<blockquote>
<p>你知道列表推导式吗？其实生成器推导式与列表推导式很相近，只是把中括号变成小括号：</p>
</blockquote>
<pre><code>gen = (x * x for x in range(5) if x % 2 ==0)
print (type(gen))
for i in gen:
  print(i)

</code></pre>
<h4 id=""></h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我在百度什么]]></title>
        <id>https://yes5144.github.io//post/wo-zai-bai-du-shi-me</id>
        <link href="https://yes5144.github.io//post/wo-zai-bai-du-shi-me">
        </link>
        <updated>2019-06-16T15:47:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="2019-06-16">2019-06-16</h3>
<pre><code>
## 监控redis，consul自动发现
https://blog.csdn.net/qq_25934401/article/details/82118008

## Go语言学习之html/template包(The way to go)
https://blog.csdn.net/wangshubo1989/article/details/73473412


## golang 模板(template)的常用基本语法
https://blog.csdn.net/sryan/article/details/52353937

## Golang Template 简明笔记
https://www.jianshu.com/p/05671bab2357

## Prometheus 和 Alertmanager实战配置
https://www.cnblogs.com/longcnblogs/p/9620733.html


## RESTful API 设计指南
http://www.ruanyifeng.com/blog/2014/05/restful_api.html

## vue实例
https://cn.vuejs.org/v2/guide/instance.html

## webpack,
## vue, vuex, vue-router, axios
## ES6, babel

## jenkins 安装
https://blog.csdn.net/yuanfang_jlht/article/details/51577773

## win7 下载在H盘，powershell 执行 java -jar jenkins.war
## 访问127.0.0.1:8080
[jenkins_notify_email002.html] was not found in $JENKINS_HOME/email-templates.
默认$JENKINS_HOME在C:\Users\Admin\.jenkins

## jenkins
http://www.eryajf.net/category/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/jenkins

## Jenkins 持续集成综合实战(转)
https://www.cnblogs.com/zuxing/articles/9360315.html

## salt-api 安装
https://www.cnblogs.com/xiewenming/p/7716660.html


## beego.me
https://beego.me/docs/intro/

## gin
https://github.com/gin-gonic/gin#installation
https://gin-gonic.com/zh-cn/docs/quickstart/

## edisonlz/Gin_API_Framework
https://github.com/edisonlz/Gin_API_Framework#readme

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GO语言入门]]></title>
        <id>https://yes5144.github.io//post/go-yu-yan-ru-men</id>
        <link href="https://yes5144.github.io//post/go-yu-yan-ru-men">
        </link>
        <updated>2019-06-12T13:39:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="go安装">go安装</h3>
<pre><code>1，二进制安装
2，GVM第三方工具安装
</code></pre>
<h3 id="gopath设置">GOPATH设置</h3>
<pre><code>export GOPATH=/home/apple/mygo
</code></pre>
<h3 id="获取远程包">获取远程包</h3>
<pre><code>go get github.com/astaxie/beedb

go build

go clean 移除当前源码包里面编译生成的文件。

go fmt 

go get 
这个命令在内部实际上分为两步操作，1、下载；2、go install

go install 这个命令在内部实际上分成两步操作：第一步是生成结果文件（可执行文件或者.a包），第二步会把编译好的结果移到$GOPATH、pkg或者$GOPATH/bin
</code></pre>
<h4 id="go-doc">go doc</h4>
<pre><code>如果是buildin包，那么执行 go doc buildin;
如果是http包，那么执行 go doc net/http;
查看某一个包里面的函数，则执行godoc fmt Printf;
查看相应的代码，执行godoc -src fmt Printf

</code></pre>
<h4 id="其他命令">其他命令</h4>
<pre><code>go fix 
go version
go run
go env 
go  list
go help get
</code></pre>
<h3 id="22-go语言基础">2.2 Go语言基础</h3>
<pre><code>## 定义变量
var  varName type
var  vName1,  vName2, vName3 type
var  vName type = value
var  vName1, vName2 type =v1, v2

var vName1, vName2 = v1, v2
vName1, vName2 := v1, v2 ## 简短说明，只能在函数内部使用

## 常量
const  constantName = value
const Pi float32 = 3.141592
const i =10000
const MaxThread =90
const prefix = &quot;channel&quot;

## 内置数据类型
### Boolean
### 数值类型
### 字符串
### 错误类型
err := errors.New(&quot;emit macho dwarf: elf header corrupted&quot;)
if err != nil {
    fmt.Print(err)
}

</code></pre>
<h3 id="if-for-switch">if  for  switch</h3>
<pre><code>
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pip常用命令组合]]></title>
        <id>https://yes5144.github.io//post/pip-chang-yong</id>
        <link href="https://yes5144.github.io//post/pip-chang-yong">
        </link>
        <updated>2019-06-11T14:34:02.000Z</updated>
        <content type="html"><![CDATA[<p>pip freeze
pip list
pip check
pip search
pip install numpy
pip uninstall numpy</p>
<p>pip install ipython</p>
<p>print ('*'.join(['2','8','4','5']))</p>
<p>a = &quot;This sentence will be split to word list.&quot;
print(a.split())
此外需要注意的是split()和split(&quot; &quot;)是有区别的，后者在遇到连续多个空格的时候会分割出多个空字符串。</p>
<p>filename = 'image00015'
print(filename.startswith('image'))</p>
<p>index = '15'
filename = 'image' + index.zfill(7)
print(filename)
zfill(width)指定一个宽度，如果数字的长度大于宽度则什么也不做，但是如果小于宽度剩下的位会用0补齐。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python多进程（multiprocessing）共享变量]]></title>
        <id>https://yes5144.github.io//post/python-duo-jin-cheng-multiprocessinggong-xiang-bian-liang</id>
        <link href="https://yes5144.github.io//post/python-duo-jin-cheng-multiprocessinggong-xiang-bian-liang">
        </link>
        <updated>2019-06-01T05:54:36.000Z</updated>
        <content type="html"><![CDATA[<pre><code>#!/usr/bin/env python2
# coding: utf8
import multiprocessing

def foo(h,context):
    if h%2 == 0:
        print (h)
    else:
        context.append(h)

if __name__ == &quot;__main__&quot;:
    ## 设置共享list
    con = multiprocessing.Manager().list()
    ## 设置进程池大小
    p = multiprocessing.Pool(2)
    for i in range(18):
        # con = multiprocessing.Manager().list()
        p.apply_async(foo,args=(i,con))
    p.close()
    p.join()
    print con
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的运维笔记]]></title>
        <id>https://yes5144.github.io//post/wo-de-yun-wei-bi-ji</id>
        <link href="https://yes5144.github.io//post/wo-de-yun-wei-bi-ji">
        </link>
        <updated>2019-06-01T03:59:10.000Z</updated>
        <content type="html"><![CDATA[<p>挖坑填坑；
keep coding；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://yes5144.github.io//post/hello-gridea</id>
        <link href="https://yes5144.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>