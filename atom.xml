<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yes5144.github.io/</id>
    <title>Talk is cheap. Show me the code</title>
    <updated>2019-08-18T09:36:23.435Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yes5144.github.io/"/>
    <link rel="self" href="https://yes5144.github.io//atom.xml"/>
    <subtitle>你第十年的目标是CTO，你打算如何实现？</subtitle>
    <logo>https://yes5144.github.io//images/avatar.png</logo>
    <icon>https://yes5144.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Talk is cheap. Show me the code</rights>
    <entry>
        <title type="html"><![CDATA[Yum部署k8s]]></title>
        <id>https://yes5144.github.io//post/k8s-bu-shu</id>
        <link href="https://yes5144.github.io//post/k8s-bu-shu">
        </link>
        <updated>2019-08-18T07:47:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="k8s安装入门">k8s安装入门</h2>
<pre><code>### 参考链接：https://www.cnblogs.com/sxdcgaq8080/p/10621437.html

## 准备工作
192.168.204.133  k8s-master01
192.168.204.134  k8s-node01
192.168.204.135  k8s-node02

### 分别设置主机名
hostnamectl --static set-hostname  k8s-master01
hostnamectl --static set-hostname  k8s-node01
hostnamectl --static set-hostname  k8s-node02


### 修改/etc/hosts

cat &gt;&gt;/etc/hosts &lt;&lt;EOF
192.168.204.133    k8s-master01
192.168.204.133    etcd
192.168.204.133    registry
192.168.204.134    k8s-node01
192.168.204.135    k8s-node02
EOF

### 关闭防火墙，SELinux
systemctl stop firewalld.service
systemctl disable firewalld.service

### 再使用查看命令查看，如果是如下效果，说明成功
firewall-cmd --state

### ntpdate
echo '*/10 * * * * root ntpdate  ntp2.aliyun.com' &gt;&gt; /etc/crontab
</code></pre>
<h3 id="一-主节点master01">一、主节点master01</h3>
<pre><code>主节点需要安装

etcd 存储数据中心

flannel k8s的一种网络方案

kubernetes 【包含：kube-api-server  controllerManager   Scheduler 】

## 1,etcd的安装
### 1.1 命令安装
yum install -y etcd
### 1.2 配置文件
cd  /etc/etcd
cp  etcd.conf  etcd.conf.default
cat etcd.conf
ETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;
ETCD_LISTEN_CLIENT_URLS=&quot;http://0.0.0.0:2379,http://0.0.0.0:4001&quot;
ETCD_NAME=&quot;master&quot;
ETCD_ADVERTISE_CLIENT_URLS=&quot;http://etcd:2379,http://etcd:4001&quot;


### 1.3 启动etcd服务并验证
systemctl start etcd
systemctl enable etcd
systemctl status etcd

#### 检查健康状况
etcdctl -C http://etcd:2379 cluster-health
etcdctl -C http://etcd:4001 cluster-health

## 2,flannel的安装
### 2.1 安装命令


### 2.2 配置文件 /etc/sysconfig/flanneld
FLANNEL_ETCD_ENDPOINTS=&quot;http://etcd:2379&quot;
FLANNEL_ETCD_PREFIX=&quot;/atomic.io/network&quot;

### 2.3 配置etcd中关于flannel的key
etcdctl mk /atomic.io/network/config '{ &quot;Network&quot;: &quot;10.0.0.0/16&quot; }'

### 2.4 启动flannel服务，并设置开机自启
systemctl start flanneld.service
systemctl status flanneld.service
systemctl enable flanneld.service

## 3,安装kubernetes
### 3.1 安装命令
yum install kubernetes

### 3.2安装后，需要修改配置
### 配置修改是为了下面这些需要运行的组件
kube-api-server
kuber-scheduler
kube-controller-manager

vim /etc/kubernetes/apiserver

vim /etc/kubernetes/config


### 3.3 分别启动三个组件服务，并且设置为自启动
systemctl start kube-apiserver.service
systemctl start kube-controller-manager.service
systemctl start kube-scheduler.service


systemctl enable kube-apiserver.service
systemctl enable kube-controller-manager.service
systemctl enable kube-scheduler.service


## 4,安装docker
### 4.1 安装docker命令：
yum install  -y docker 
### 4.2 启动docker服务命令：
service docker start
### 4.3 docker加入自启动服务命令：
chkconfig docker on

</code></pre>
<h3 id="二-子节点安装">二、子节点安装</h3>
<pre><code>

## 1, 安装etcd


## 2, 安装flannel


## 3, 安装kubernetes


## 4, 安装docker


</code></pre>
<h3 id="三验证集群状态">三.验证集群状态</h3>
<pre><code>1.master节点执行命令，查看端点信息
kubectl get endpoints

2.master节点执行命令，查看集群信息
kubectl cluster-info

3.master节点执行命令，获取节点信息
kubectl get nodes


## 部署app
kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080
kubectl run redis --image=docker.io/redis --port=6379

export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{&quot;\n&quot;}}{{end}}')
echo Name of the Pod: $POD_NAME

curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/


kubectl describe pods

kubectl  logs $POD_NAME

kubectl exec $POD_NAME env

kubectl exec -it $POD_NAME bash

kubectl get deployments

kubectl scale deployments/kubernetes-bootcamp --replicas=4

kubectl get pods -o wide

kubectl describe deployments/kubernetes-bootcamp

</code></pre>
<h3 id="其他">其他</h3>
<pre><code>######################
## 配置k8s repo
cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
setenforce 0


yum install -y kubelet kubeadm kubectl
systemctl enable kubelet &amp;&amp; systemctl start kubelet

## 配置docker-ce repo
## 
# step 1: 安装必要的一些系统工具
sudo yum install -y yum-utils device-mapper-persistent-data lvm2
# Step 2: 添加软件源信息
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# Step 3: 更新并安装 Docker-CE
sudo yum makecache fast
sudo yum -y install docker-ce
# Step 4: 开启Docker服务
sudo service docker start

注意：其他注意事项在下面的注释中
# 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。
# vim /etc/yum.repos.d/docker-ce.repo
#   将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[kubeadm部署k8s]]></title>
        <id>https://yes5144.github.io//post/kubeadm-bu-shu-k8s</id>
        <link href="https://yes5144.github.io//post/kubeadm-bu-shu-k8s">
        </link>
        <updated>2019-08-18T00:49:21.000Z</updated>
        <content type="html"><![CDATA[<h3 id=""></h3>
<pre><code>## https://www.bookstack.cn/read/kubernetes-handbook/SUMMARY.md
## https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql-主从复制]]></title>
        <id>https://yes5144.github.io//post/mysql-zhu-cong</id>
        <link href="https://yes5144.github.io//post/mysql-zhu-cong">
        </link>
        <updated>2019-08-11T03:39:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="mariadbmysql的主从复制部署docker">MariaDB/Mysql的主从复制部署(Docker)</h3>
<pre><code>### 原文链接：https://blog.csdn.net/clearlxj/article/details/88313033

### 注意文中有一个笔误： /home/lxj/hedisql  /home/lxj/heidisql/

## 修改master_my.cnf，在 [mysqld] 节点下添加

[mysqld]
server-id=1
log_bin=master-bin
binlog-ignore-db=mysql
binlog-ignore-db=information_schema
binlog-ignore-db=performance_schema
binlog-ignore-db=test
innodb_flush_log_at_trx_commit=1
binlog_format=mixed


## 修改slave1_my.cnf，在 [mysqld] 节点下添加

[mysqld]
server-id=2
relay-log-index=slave-relay-bin.index
relay-log=slave-relay-bin
relay_log_recovery=1

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql-Docker部署mha]]></title>
        <id>https://yes5144.github.io//post/mysql-mha</id>
        <link href="https://yes5144.github.io//post/mysql-mha">
        </link>
        <updated>2019-08-11T03:23:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="docker搭建mariadbmysql-mha高可用集群">Docker搭建MariaDB/Mysql MHA高可用集群</h3>
<pre><code>原文链接：https://blog.csdn.net/clearlxj/article/details/88422206

## Checking if super_read_only is defined and turned on..DBD::mysql::st execute failed: Unknown system variable 'super_read_only' at /usr/share/perl5/vendor_perl/MHA/SlaveUtil.pm line 245.
报错原因：mha4mysql版本问题，
解决办法：最后将MHA的版本换成mha4mysql-0.56。

### mysql--docker化实践：https://blog.csdn.net/weixin_34290390/article/details/89123731
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql-GTID主从复制]]></title>
        <id>https://yes5144.github.io//post/mysql-gtid-zhu-cong</id>
        <link href="https://yes5144.github.io//post/mysql-gtid-zhu-cong">
        </link>
        <updated>2019-08-10T15:15:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基于gtid-主从复制">基于gtid 主从复制</h3>
<pre><code>参考链接：https://blog.csdn.net/weixin_43407305/article/details/87911235
参考链接：https://blog.csdn.net/martingpf/article/details/81115187
参考链接：https://blog.csdn.net/leshami/article/details/50630691
参考链接：https://blog.csdn.net/qq_43094192/article/details/83994952

MySQL 5.6引入的GTID(Global Transaction IDs)使得其复制功能的配置、监控及管理变得更加易于实现，且更加健壮.

MySQL 5.6中使用复制功能，其服务配置段[mysqld]中于少应该定义如下选项：
binlog-format：二进制日志的格式，有row、statement和mixed几种类型；需要注意的是：当设置隔离级别为READ-COMMITED必 须设置二进制日志格式为ROW，现在MySQL官方认为STATEMENT这个已经不再适合继续使用,但mixed类型在默认的事务隔离级别下，可能会导致主从数据不一致；
log-slave-updates、gtid-mode、enforce-gtid-consistency、report-port和report-host：用于启动GTID及满足附属的其它需求；
master-info-repository和relay-log-info-repository：启用此两项，可用于实现在崩溃时保证二进制及从服务器安全的功能；
sync-master-info：启用之可确保无信息丢失；
slave-paralles-workers：设定从服务器的SQL线程数；0表示关闭多线程复制功能；
binlog-checksum、master-verify-checksum和slave-sql-verify-checksum：启用复制有关的所有校验功能；
binlog-rows-query-log-events：启用之可用于在二进制日志记录事件相关的信息，可降低故障排除的复杂度；
log-bin：启用二进制日志，这是保证复制功能的基本前提；
server-id：同一个复制拓扑中的所有服务器的id号必须惟一；

GTID的概念：
1）全局事务标识：global transaction identifiers。
2）GTID是一个事务一一对应，并且全局唯一ID。
3）一个GTID在一个服务器上只执行一次，避免重复执行导致数据混乱或者主从不一致。
4）GTID用来代替传统复制方法，不再使用MASTER_LOG_FILE+MASTER_LOG_POS开启复制。而是使用MASTER_AUTO_POSTION=1的方式开始复制。
5）MySQL-5.6.5开始支持的，MySQL-5.6.10后开始完善。
6）在传统的slave端，binlog是不用开启的，但是在GTID中slave端的binlog是必须开启的，目的是记录执行过的GTID（强制）。

GTID组成：
GTID = source_id:transaction_id
source_id，用于鉴别原服务器，即mysql服务器唯一的的server_uuid，由于GTID会传递到slave，所以也可以理解为源ID。
transaction_id，为当前服务器上已提交事务的一个序列号，通常从1开始自增长的序列，一个数值对应一个事务。        
示例：          
3E11FA47-71CA-11E1-9E33-C80AA9429562:23
前面的一串为服务器的server_uuid，即3E11FA47-71CA-11E1-9E33-C80AA9429562，后面的23为transaction_id

GTID原理：
1、当一个事务在主库端执行并提交时，产生GTID，一同记录到binlog日志中。
2、binlog传输到slave,并存储到slave的relaylog后，读取这个GTID的这个值设置gtid_next变量，即告诉Slave，下一个要执行的GTID值。
3、sql线程从relay log中获取GTID，然后对比slave端的binlog是否有该GTID。
4、如果有记录，说明该GTID的事务已经执行，slave会忽略。
5、如果没有记录，slave就会执行该GTID事务，并记录该GTID到自身的binlog，
   在读取执行事务前会先检查其他session持有该GTID，确保不被重复执行。
6、在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有就用全部扫描。

一、简单主从模式配置步骤
1、配置主从节点的服务配置文件
1.1、配置master节点：
[mysqld]
binlog-format=ROW
log-bin=master-bin
log-slave-updates=true  ###从服务器更新同步二进制日志信息，适用于高可用中，从服务器升级主服务器用
gtid-mode=on 
enforce-gtid-consistency=true
master-info-repository=TABLE
relay-log-info-repository=TABLE
sync-master-info=1
slave-parallel-workers=2
binlog-checksum=CRC32
master-verify-checksum=1
slave-sql-verify-checksum=1
binlog-rows-query-log_events=1
server-id=1
report-port=3306
port=3306
datadir=/mydata/
socket=/tmp/mysql.sock
report-host=edong1

1.2、配置slave节点：
[mysqld]
binlog-format=ROW
log-slave-updates=true
gtid-mode=on 
enforce-gtid-consistency=true
master-info-repository=TABLE
relay-log-info-repository=TABLE
sync-master-info=1
slave-parallel-workers=2
binlog-checksum=CRC32
master-verify-checksum=1
slave-sql-verify-checksum=1
binlog-rows-query-log_events=1
server-id=11
report-port=3306
port=3306
log-bin=mysql-bin.log
datadir=/mydata/
socket=/tmp/mysql.sock
report-host=edong2
slave节点配置和master节点配置一样的目的：主服务器挂了，从服务器可以快速升级为主服务器
2、创建复制用户
mysql&gt;grant replication slave on *.* to 'repluser'@'192.168.0.%' identified by 'replpassword';
3、为备节点提供初始数据集
锁定主表，备份主节点上的数据，将其还原至从节点；如果没有启用GTID，在备份时需要在master上使用show master status命令查看二进制日志文件名称及事件位置，以便后面启动slave节点时使用。
4、启动从节点的复制线程
如果启用了GTID功能，则使用如下命令：
mysql&gt;change master to master_host='192.168.0.202',master_user='repluser',master_password='replpassword',master_auto_position=1;

半同步复制

1、分别在主从节点上安装相关的插件
master&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
slave&gt; INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';

2、启用半同步复制
在master上的配置文件中，添加
rpl_semi_sync_master_enabled=ON
在至少一个slave节点的配置文件中添加
rpl_semi_sync_slave_enabled=ON
而后重新启动mysql服务即可生效。

或者，也可以mysql服务上动态启动其相关功能：
master&gt; SET GLOBAL rpl_semi_sync_master_enabled = ON;
slave&gt; SET GLOBAL rpl_semi_sync_slave_enabled = ON;
slave&gt; STOP SLAVE IO_THREAD; START SLAVE IO_THREAD;

3、确认半同步功能已经启用
master&gt; CREATE DATABASE magedudb;
master&gt; SHOW STATUS LIKE 'Rpl_semi_sync_master_yes_tx';

slave&gt; SHOW DATABASES;

</code></pre>
<h3 id="主从复制">主从复制</h3>
<pre><code>主从复制过程存在三个线程，Master端的I/O线程，Slave的I/O线程与SQL线程。Master端需要开启binlog日志，Slave端需要开启relaylog。
1、Slave端的I/O读取master.info文件，获取binlog文件名和位置点，然后向Master端的I/O线程请求，该binlog文件名和位置点的binlog信息。
（master.info文件在配置主从复制时使用change master命令来指定生成）
2、Master端的I/O线程会根据Slave端的I/O线程请求的信息来读取Master的binlog日志信息与及读取到最新的binlog文件名和位置点一同返回给Slave的I/O线程。
3、Slave端的I/O线程会把获取到的binlog日志写入relaylog（中继日志）文件中，并且更新master.info文件信息。（把读取到Master最新的binlog日志文件名和位置点更新到master.info文件中，下一次当前位置去读取Master的binlog日志）
4、Slave端的SQL线程会定期读取relaylog，把二进制的日志解析成SQL语句，并执行这些SQL语句，同步数据到从库中

原文链接：https://blog.csdn.net/weixin_43407305/article/details/87911235
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[k8s 学习]]></title>
        <id>https://yes5144.github.io//post/k8s-xue-xi</id>
        <link href="https://yes5144.github.io//post/k8s-xue-xi">
        </link>
        <updated>2019-08-08T16:12:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1docker的安装">1，docker的安装</h3>
<pre><code>## 使用阿里云镜像加速安装下载docker-ce
## 参考链接：https://yq.aliyun.com/articles/110806

# step 1: 安装必要的一些系统工具
sudo yum install -y yum-utils device-mapper-persistent-data lvm2
# Step 2: 添加软件源信息
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# Step 3: 更新并安装 Docker-CE
sudo yum makecache fast
sudo yum -y install docker-ce
# Step 4: 开启Docker服务
sudo service docker start

</code></pre>
<h3 id="2配置-docker-加速器">2，配置 docker 加速器</h3>
<pre><code>## 参考链接https://www.daocloud.io/mirror
## 该脚本可以将 --registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。
curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io



</code></pre>
<h3 id="5k8s基础命令">5，k8s基础命令</h3>
<pre><code>## https://kubernetes.io/docs/tutorials/

## 
kubectl  get  nodes
kubectl  cluster-info
## deployment
kubectl  run kubernetes-bootcamp  --image=docker.io/jocatalin/kubernetes-bootcamp:v1  --port=8080
kubectl  get  nodes
## 
kubectl  expose  deployment/kubernets-bootcamp  --type=&quot;NodePort&quot;  --port=8080
kubectl  get  services

kubectl delete service -l run=kubernetes-bootcamp
kubectl get services

## scale
kubectl  get  deployments
kubectl  scale  deployments/kubernetes-bootcamp  --replicas=3
kubectl  get  deployments
kubectl  get  nodes

kubectl  scale  deployments/kubernetes-bootcamp  --replicas=2
kubectl  get  deployments
kubectl  get  nodes

## 
kubectl  set  image  deployments/kubernetes-bootcamp  kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2

kubectl  rollout  undo  deployments/kubernetes-bootcamp
kubectl  get  nodes

kubectl  get  namespace

</code></pre>
<h3 id="kubectl-管理应用程序生命周期">kubectl 管理应用程序生命周期</h3>
<pre><code>1、创建
kubectl run nginx --replicas=3 --image=nginx:1.14 --port=80
kubectl get deploy,pods

2、发布
kubectl expose deployment nginx --port=80  --type=NodePort  --target-port=80  --name=nginx-service
kubectl  get service

3、更新
kubectl  set image deployment/nginx  nginx=nginx:1.15

4、回滚
kubectl rollout history deployment/nginx
kubectl rollout undo deployment/nginx

5、删除
kubectl  delete deploy/nginx
kubectl  delete svc/nginx-service

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 解压缩命令]]></title>
        <id>https://yes5144.github.io//post/linux-jie-ya-suo-ming-ling</id>
        <link href="https://yes5144.github.io//post/linux-jie-ya-suo-ming-ling">
        </link>
        <updated>2019-08-07T23:23:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="不解压缩查看压缩包内文件列表">不解压缩，查看压缩包内文件列表</h3>
<pre><code>tar -ztvf file.tar.gz

tar.gz
tar tzvf xxx.tar.gz

tar.bz2
tar tjvf xxx.tar.bz2

zip
unzip -l xxx.zip  (简略模式)
unzip -v xxx.zip (详细模式)

rar
unrar l xxx.rar(简略模式)
unrar v xxx.rar(详细模式)

 

linux压缩和解压缩命令大全

tar命令

　　解包：tar zxvf FileName.tar

　　打包：tar czvf FileName.tar DirName

gz命令

　　解压1：gunzip FileName.gz

　　解压2：gzip -d FileName.gz

　　压缩：gzip FileName

　　.tar.gz 和 .tgz

　　解压：tar zxvf FileName.tar.gz

　　压缩：tar zcvf FileName.tar.gz DirName

   压缩多个文件：tar zcvf FileName.tar.gz DirName1 DirName2 DirName3 ...

bz2命令

　　解压1：bzip2 -d FileName.bz2

　　解压2：bunzip2 FileName.bz2

　　压缩： bzip2 -z FileName

　　.tar.bz2

　　解压：tar jxvf FileName.tar.bz2

　　压缩：tar jcvf FileName.tar.bz2 DirName

bz命令

　　解压1：bzip2 -d FileName.bz

　　解压2：bunzip2 FileName.bz

　　压缩：未知

　　.tar.bz

　　解压：tar jxvf FileName.tar.bz

Z命令

　　解压：uncompress FileName.Z

　　压缩：compress FileName

　　.tar.Z

　　解压：tar Zxvf FileName.tar.Z

　　压缩：tar Zcvf FileName.tar.Z DirName

zip命令

　　解压：unzip FileName.zip

　　压缩：zip FileName.zip DirName

rar命令

　　解压：rar a FileName.rar

　　压缩：r ar e FileName.rar
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promql 查询语法]]></title>
        <id>https://yes5144.github.io//post/promql-cha-xun-yu-fa</id>
        <link href="https://yes5144.github.io//post/promql-cha-xun-yu-fa">
        </link>
        <updated>2019-07-28T14:51:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="首先部署一套prometheus访问9090端口">首先部署一套prometheus，访问9090端口</h3>
<pre><code>https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-query-language
## 简单使用
http_requests_total{code=&quot;200&quot;,handler=&quot;alerts&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;}=(20889@1518096812.326)
http_requests_total{code=&quot;200&quot;,handler=&quot;graph&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;}=(21287@1518096812.326)

## 支持正则表达式
http_requests_total{environment=~&quot;staging|testing|development&quot;,method!=&quot;GET&quot;}

## 查询范围
http_request_total{}[5m]
http_request_total{} # 瞬时向量表达式，选择当前最新的数据
http_request_total{}[5m] # 区间向量表达式，选择以当前时间为基准，5分钟内的数据

## 聚合操作
# 查询系统所有http请求的总量
sum(http_request_total)

# 按照mode计算主机CPU的平均使用时间
avg(node_cpu) by (mode)

# 按照主机查询各个主机的CPU使用率
sum(sum(irate(node_cpu{mode!='idle'}[5m]))  / sum(irate(node_cpu[5m]))) by (instance)

# top 5
topk(5, http_requests_total)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Grafana + zabbix 打造监控大屏]]></title>
        <id>https://yes5144.github.io//post/grafana-zabbix-da-zao-jian-kong-da-ping</id>
        <link href="https://yes5144.github.io//post/grafana-zabbix-da-zao-jian-kong-da-ping">
        </link>
        <updated>2019-07-28T13:47:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="每天看着zabbix展示界面是不是有点腻歪了要不要换个高大上提升一下逼格">每天看着zabbix展示界面是不是有点腻歪了，要不要换个高大上提升一下逼格？？？</h3>
<p>参考链接：</p>
<pre><code>## 分布式监控系统Zabbix--使用Grafana进行图形展示
https://www.cnblogs.com/kevingrace/p/7108060.html
## 10分钟打造炫酷的监控大屏
http://www.ywjt.org/index.php/archives/1802
## 徒手教你制作运维监控大屏
https://www.cnblogs.com/zhangs1986/p/11180694.html
## 官方地址：http://docs.grafana-zabbix.org
## 项目Demo：http://play.grafana.org/
## 项目github：https://github.com/grafana/grafana
</code></pre>
<h3 id="当你耐心看完如上链接相信已经差不多ok了下面只是我的坑友情提示一下">当你耐心看完如上链接，相信已经差不多OK了，下面只是我的坑友情提示一下：</h3>
<h4 id="1由于本人采用的是tar包解压的方式启动所以plugins在安装目录的dataplugins你可以修改配置文件重新指向varlibgrafanaplugins">1，由于本人采用的是tar包解压的方式启动，所以plugins在安装目录的data/plugins/，你可以修改配置文件重新指向/var/lib/grafana/plugins/</h4>
<pre><code>## 获取可用插件列表
grafana-cli plugins list-remote
 
## 安装zabbix插件
grafana-cli plugins install alexanderzobnin-zabbix-app
 
## 安装插件完成之后重启garfana服务
service grafana-server restart

## 安装其他图形插件
# 饼图展示
grafana-cli plugins install grafana-piechart-panel
#钟表形展示
grafana-cli plugins install grafana-clock-panel
grafana-cli plugins install briangann-gauge-panel
#字符型展示
grafana-cli plugins install natel-discrete-panel
#服务器状态
grafana-cli plugins install vonage-status-panel
</code></pre>
<h4 id="2在grafana官网找一个zabbix插件稍稍修改应用">2，在grafana官网找一个zabbix插件，稍稍修改应用</h4>
<pre><code>https://grafana.com/grafana/dashboards/6098

</code></pre>
<h4 id="有兴趣开发一个grafana插件">有兴趣开发一个grafana插件</h4>
<p>https://juejin.im/post/5addbcbd5188256715474452</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git和Svn 差异化打包]]></title>
        <id>https://yes5144.github.io//post/git-he-svn-chai-yi-hua-da-bao</id>
        <link href="https://yes5144.github.io//post/git-he-svn-chai-yi-hua-da-bao">
        </link>
        <updated>2019-07-18T15:40:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="git">Git</h3>
<pre><code>git diff这个命令能比较两个提交之间的差异，使用–name-only参数可以只显示文件名。例如：

git diff 608e120 4abe32e --name-only

打包差异文件
git diff 608e120 4abe32e --name-only | xargs zip update.zip

备注：608e120和4abe32e为前后两个提交的commit id

原文：https://blog.csdn.net/liuxinfa/article/details/82878640 
</code></pre>
<h3 id="svn">Svn</h3>
<pre><code>最近接手一个PHP项目，修复GUG和优化功能，由于是已经在用的项目，并且诸如附件上传都是保存到WEB目录下的，

所以不宜采用全量部署的方式来更新软件，最好用增量部署来更新服务器的WEB目录。

程序代码采用SVN管理，在主干上开发，每次部署都建一个tag，这样通过比较tag和主干的差别就可以知道有哪些文件发生了变动。具体的命令格式是： 

svn diff --summarize http://rep_url/tags/proj1_090214 http://rep_url/trunk/proj1 &gt;diff.txt

这个命令比较了 proj1_090214 和 proj1 的差异，并将差异信息输出到文件 diff.txt
summarize  选项的含义是只显示结果的概要，不显示文件的具体差异。

有了diff.txt，就可以知道需要部署哪些文件了，感觉很方便

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[沉迷学习]]></title>
        <id>https://yes5144.github.io//post/chen-mi-xue-xi</id>
        <link href="https://yes5144.github.io//post/chen-mi-xue-xi">
        </link>
        <updated>2019-07-18T01:00:32.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Python</li>
<li>Django</li>
<li>Golang</li>
<li>Beego</li>
<li>Docker</li>
<li>K8s</li>
<li>Linux架构师</li>
<li>chinaielts</li>
</ul>
<pre><code>## python
https://github.com/jackfrued/Python-100-Days

## k8s
https://github.com/opsnull/follow-me-install-kubernetes-cluster

## beego
https://www.jianshu.com/nb/27703855
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go 开发环境部署]]></title>
        <id>https://yes5144.github.io//post/go-kai-fa-huan-jing-bu-shu</id>
        <link href="https://yes5144.github.io//post/go-kai-fa-huan-jing-bu-shu">
        </link>
        <updated>2019-07-16T15:14:03.000Z</updated>
        <content type="html"><![CDATA[<h4 id="依赖包在golangorg">依赖包在golang.org ???</h4>
<pre><code>git clone https://github.com/golang/net.git $GOPATH/src/github.com/golang/net
git clone https://github.com/golang/sys.git $GOPATH/src/github.com/golang/sys
git clone https://github.com/golang/tools.git $GOPATH/src/github.com/golang/tools
git clone https://github.com/golang/sync.git $GOPATH/src/github.com/golang/sync
git clone https://github.com/golang/lint.git $GOPATH/src/github.com/golang/lint
git clone https://github.com/golang/text.git $GOPATH/src/github.com/golang/text

mkdir -p  $GOPATH/src/golang.org/x
cp -a $GOPATH/src/github.com/golang/  $GOPATH/src/golang.org/x

go get -v github.com/rogpeppe/godef
go get -v github.com/mdempsky/gocode
go get -v github.com/stamblerre/gocode
go get -v golang.org/x/tools/cmd/goimports
go get -v github.com/ramya-rao-a/go-outline
go get -v golang.org/x/tools/cmd/gopls
go get -u github.com/spf13/cobra/cobra

</code></pre>
<h4 id="vscode-go代码补全">vscode go代码补全</h4>
<pre><code>https://maiyang.me/post/2018-09-14-tips-vscode/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 请空表]]></title>
        <id>https://yes5144.github.io//post/mysql-qing-kong-biao</id>
        <link href="https://yes5144.github.io//post/mysql-qing-kong-biao">
        </link>
        <updated>2019-07-15T15:31:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code>SET FOREIGN_KEY_CHECKS = 0;
TRUNCATE `events`;
TRUNCATE `problem`;

set FOREIGN_key_checks =1;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prometheus 入门]]></title>
        <id>https://yes5144.github.io//post/prometheus-ru-men</id>
        <link href="https://yes5144.github.io//post/prometheus-ru-men">
        </link>
        <updated>2019-07-13T11:32:15.000Z</updated>
        <content type="html"><![CDATA[<p>prometheus</p>
<p>promOL</p>
<pre><code>http_requests_total[5m]
rate(http_requests_total[5m])


http_request_duration_microseconds_count{handler=&quot;query&quot;}
</code></pre>
<h4 id="这里提供一些其他常用的表示式">这里提供一些其他常用的表示式：</h4>
<pre><code>查询主机使用率

1 - avg by (agentIP) (irate(node_cpu{agentIP=~&quot;$machine&quot;, mode=&quot;idle&quot;}[5m]))
查询主机磁盘IO

irate(node_disk_io_time_ms{agentIP=~'$machine',device!~'^(md\\d+$|dm-)'}[5m])
查询主机内存使用量

(node_memory_MemTotal{agentIP=&quot;101.37.26.244&quot;} - node_memory_MemAvailable{agentIP=&quot;101.37.26.244&quot;}) / node_memory_MemTotal{agentIP=&quot;101.37.26.244&quot;}
除了本文中示例的表达式功能以外，Prometheus还提供了其它丰富的查询，操作符以及表达式。包括：运算符，聚合,函数等等。

http://ylzheng.com/2018/01/17/prometheus-sd-and-relabel/


通过指标io_namespace_http_requests_total我们可以：

查询应用的请求总量
# PromQL
sum(io_namespace_http_requests_total)


查询每秒Http请求量
# PromQL
sum(rate(io_wise2c_gateway_requests_total[5m]))


查询当前应用请求量Top N的URI
# PromQL
topk(10, sum(io_namespace_http_requests_total) by (path))

事件发生总的次数
# 含义：当前http请求发生总次数为12次
io_namespace_http_requests_latency_seconds_summary_count{path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,} 12.0
事件产生的值的总和
# 含义：这12次http请求的总响应时间为 51.029495508s
io_namespace_http_requests_latency_seconds_summary_sum{path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,} 51.029495508
事件产生的值的分布情况
# 含义：这12次http请求响应时间的中位数是3.052404983s
io_namespace_http_requests_latency_seconds_summary{path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,quantile=&quot;0.5&quot;,} 3.052404983
# 含义：这12次http请求响应时间的9分位数是8.003261666s
io_namespace_http_requests_latency_seconds_summary{path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,quantile=&quot;0.9&quot;,} 8.003261666
使用Collector暴露业务指标

http://ylzheng.com/2018/03/12/prometheus-alertmanager-ha/

https://learnku.com/articles/22193#098370

https://songjiayang.gitbooks.io/prometheus/content/

https://tizeen.github.io/2018/04/21/prometheus+node_exporter+alertmanager%E7%9B%91%E6%8E%A7%E4%B8%BB%E6%9C%BA%E5%AE%9E%E8%B7%B5/

https://www.cnblogs.com/fairjm/p/start_prometheus.html

https://www.ctolib.com/docs/sfile/prometheus-book/sd/service-discovery-with-consul.html
https://blog.csdn.net/polo2044/article/details/83963211

http://docs.flycloud.me/docs/ELKStack/elasticsearch/other/grafana.html

https://blog.52itstyle.vip/archives/2049/

https://juejin.im/entry/5bc411245188255c5721663a
</code></pre>
<h4 id="grafana-命令行操作">grafana 命令行操作</h4>
<pre><code>列出可用的插件
#grafana-cli plugins list-remote
 
安装最新版本的插件
#grafana-cli plugins install &lt;plugin-id&gt;
 
安装特定版本的插件
#grafana-cli plugins install &lt;plugin-id&gt; &lt;version&gt;
 
列出安装的插件
#grafana-cli plugins ls
 
更新所有安装的插件
#grafana-cli plugins update-all
 
更新一个插件
#grafana-cli plugins update &lt;plugin-id&gt;
 
删除一个插件
#grafana-cli plugins remove &lt;plugin-id&gt;

https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-node-exporter

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pycharm 常用设置]]></title>
        <id>https://yes5144.github.io//post/pycharm-chang-yong-she-zhi</id>
        <link href="https://yes5144.github.io//post/pycharm-chang-yong-she-zhi">
        </link>
        <updated>2019-07-13T11:30:47.000Z</updated>
        <content type="html"><![CDATA[<h4 id="pycharm使用文档">pycharm使用文档</h4>
<pre><code>1 为项目配置Python解释器
	File &gt; Settings &gt; Project:项目名称 &gt; Project Interpreter 这里可以选择各种解释器
	
2 创建Python文件
	- 创建Python file
	- 创建package 这说明是可以当做Python模块导出的？
	
3 安装第三方模块
	Project:项目名称 &gt; Project Interpreter &gt; 绿色+号，搜索你想要安装的模块 &gt; Install Package
	
4 常用设置（外观、界面）
	- 菜单字体及大小
		File &gt; Settings &gt; Appearance &amp; Behavior &gt; Overrode default fonts
	- Console 和Terminal字体大小
		Editor &gt; Colors &amp; Font &gt; Console Font
	- 设置文件编码
		Editor &gt; File Encodings
	- 修改背景颜色
		Editor &gt; Colors &amp; Font &gt; General
	- tab=4个空格
		Editor &gt; Code Style &gt; Python
	- 字体颜色
		Editor &gt; Colors &amp; Font &gt; Python
	- 关闭自动更新
	    Appearance &amp; Behavior &gt; System Settings &gt; Updates
	- 脚本头设置
		Editor &gt; File and Code Templates &gt; Python Script
		自动日期：Date: ${DATE}
		光标位置：#[[$END$]]# 并且勾选Enable Live Templates
	- 显示行号
		Editor &gt; General &gt; Appearance &gt; 勾选Show line numbers
	- 导入导出pycharm自定义的配置
		File &gt; Export Settings(导出)/ Import Settings(导入)
		
5 常用快捷键、如复制当前行、删除当前行、批量注释、缩进、查找和替换
	- 快捷键的查询和配置：Keymap
		快速换行： Ctrl + Enter
		快速查找： Ctrl + F
        替换： Ctrl + H
        折叠代码块：Ctrl + -
        删除当前行：Ctrl + E	
	- 滚轮放大缩小代码
	    Settings &gt; 搜索font &gt; Decrease Font Size / Increase Font Size

6 pycharm 安装插件
	Settings &gt; Plugins &gt; Browse repositories(中间那个) &gt; 搜索插件 &gt; install
	常用插件：
		- Markdown support
		- .ignore
		- BashSuport
		- IdeaVim
		- CodeGlance

7 Git配置
	- 安装好git
	- Settings &gt; Version Control &gt; Git
	
	
	pycharm快捷键及一些常用设置

1、编辑（Editing）

Ctrl + Space 基本的代码完成（类、方法、属性）
Ctrl + Alt + Space 快速导入任意类
Ctrl + Shift + Enter 语句完成
Ctrl + P 参数信息（在方法中调用参数）
Ctrl + Q 快速查看文档
Shift + F1 外部文档
Ctrl + 鼠标 简介
Ctrl + F1 显示错误描述或警告信息
Alt + Insert 自动生成代码
Ctrl + O 重新方法
Ctrl + Alt + T 选中
Ctrl + / 行注释
Ctrl + Shift + / 块注释
Ctrl + W 选中增加的代码块
Ctrl + Shift + W 回到之前状态
Ctrl + Shift + ]/[ 选定代码块结束、开始
Alt + Enter 快速修正
Ctrl + Alt + L 代码格式化
Ctrl + Alt + O 优化导入
Ctrl + Alt + I 自动缩进
Tab / Shift + Tab 缩进、不缩进当前行
Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板
Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板
Ctrl+V/Shift+Insert 从剪贴板粘贴
Ctrl + Shift + V 从最近的缓冲区粘贴
Ctrl + D 复制选定的区域或行
Ctrl + Y 删除选定的行
Ctrl + Shift + J 添加智能线
Ctrl + Enter 智能线切割
Shift + Enter 另起一行
Ctrl + Shift + U 在选定的区域或代码块间切换
Ctrl + Delete 删除到字符结束
Ctrl + Backspace 删除到字符开始
Ctrl + Numpad+/- 展开折叠代码块
Ctrl + Numpad+ 全部展开
Ctrl + Numpad- 全部折叠
Ctrl + F4 关闭运行的选项卡

2、查找/替换(Search/Replace)
F3 下一个
Shift + F3 前一个
Ctrl + R 替换
Ctrl + Shift + F 全局查找
Ctrl + Shift + R 全局替换

3、运行(Running)
Alt + Shift + F10 运行模式配置
Alt + Shift + F9 调试模式配置
Shift + F10 运行
Shift + F9 调试
Ctrl + Shift + F10 运行编辑器配置
Ctrl + Alt + R 运行manage.py任务

4、调试(Debugging)
F8 跳过
F7 进入
Shift + F8 退出
Alt + F9 运行游标
Alt + F8 验证表达式
Ctrl + Alt + F8 快速验证表达式
F9 恢复程序
Ctrl + F8 断点开关
Ctrl + Shift + F8 查看断点

5、导航(Navigation)
Ctrl + N 跳转到类
Ctrl + Shift + N 跳转到符号
Alt + Right/Left 跳转到下一个、前一个编辑的选项卡
F12 回到先前的工具窗口
Esc 从工具窗口回到编辑窗口
Shift + Esc 隐藏运行的、最近运行的窗口
Ctrl + Shift + F4 关闭主动运行的选项卡
Ctrl + G 查看当前行号、字符号
Ctrl + E 当前文件弹出
Ctrl+Alt+Left/Right 后退、前进
Ctrl+Shift+Backspace 导航到最近编辑区域
Alt + F1 查找当前文件或标识
Ctrl+B / Ctrl+Click 跳转到声明
Ctrl + Alt + B 跳转到实现
Ctrl + Shift + I查看快速定义
Ctrl + Shift + B跳转到类型声明
Ctrl + U跳转到父方法、父类
Alt + Up/Down跳转到上一个、下一个方法
Ctrl + ]/[跳转到代码块结束、开始
Ctrl + F12弹出文件结构
Ctrl + H类型层次结构
Ctrl + Shift + H方法层次结构
Ctrl + Alt + H调用层次结构
F2 / Shift + F2下一条、前一条高亮的错误
F4 / Ctrl + Enter编辑资源、查看资源
Alt + Home显示导航条F11书签开关
Ctrl + Shift + F11书签助记开关
Ctrl + #[0-9]跳转到标识的书签
Shift + F11显示书签

6、搜索相关(Usage Search)
Alt + F7/Ctrl + F7文件中查询用法
Ctrl + Shift + F7文件中用法高亮显示
Ctrl + Alt + F7显示用法

7、重构(Refactoring)
F5复制F6剪切
Alt + Delete安全删除
Shift + F6重命名
Ctrl + F6更改签名
Ctrl + Alt + N内联
Ctrl + Alt + M提取方法
Ctrl + Alt + V提取属性
Ctrl + Alt + F提取字段
Ctrl + Alt + C提取常量
Ctrl + Alt + P提取参数

8、控制VCS/Local History
Ctrl + K提交项目
Ctrl + T更新项目
Alt + Shift + C查看最近的变化
Alt + BackQuote(’)VCS快速弹出

9、模版(Live Templates)
Ctrl + Alt + J当前行使用模版
Ctrl +Ｊ插入模版

10、基本(General)
Alt + #[0-9]打开相应的工具窗口
Ctrl + Alt + Y同步
Ctrl + Shift + F12最大化编辑开关
Alt + Shift + F添加到最喜欢
Alt + Shift + I根据配置检查当前文件
Ctrl + BackQuote(’)快速切换当前计划
Ctrl + Alt + S　打开设置页
Ctrl + Shift + A查找编辑器里所有的动作
Ctrl + Tab在窗口间进行切换

一些常用设置：

1. pycharm默认是自动保存的，习惯自己按ctrl + s 的可以进行如下设置：
1. file -&gt; Setting -&gt; General -&gt; Synchronization -&gt; Save files on frame deactivation 和 Save files automatically if application is idle for .. sec 的勾去掉
2. file -&gt;Setting -&gt; Editor -&gt; Editor Tabs -&gt; Mark modified tabs with asterisk 打上勾
2. Alt + Enter: 自动添加包

3. 对于常用的快捷键，可以设置为visual studio(eclipse...)一样的：
file -&gt; Setting -&gt; Keymap -&gt; Keymaps -&gt; vuisual studio -&gt; Apply

4. Pycharm中默认是不能用Ctrl+滚轮改变字体大小的，可以在file -&gt; Setting -&gt;Editor-〉Mouse中设置

5. 要设置Pycharm的字体，要先在file -&gt; Setting -&gt;Editor-〉Editor中选择一种风格并保存，然后才可以改变

6. 在setting中搜索theme可以改变主题，所有配色统一改变
</code></pre>
]]></content>
    </entry>
</feed>