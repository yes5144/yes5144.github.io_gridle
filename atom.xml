<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yes5144.github.io/</id>
    <title>Talk is cheap. Show me the code</title>
    <updated>2019-08-11T16:34:51.366Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yes5144.github.io/"/>
    <link rel="self" href="https://yes5144.github.io//atom.xml"/>
    <subtitle>你第十年的目标是CTO，你打算如何实现？</subtitle>
    <logo>https://yes5144.github.io//images/avatar.png</logo>
    <icon>https://yes5144.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Talk is cheap. Show me the code</rights>
    <entry>
        <title type="html"><![CDATA[Mysql-主从复制]]></title>
        <id>https://yes5144.github.io//post/mysql-zhu-cong</id>
        <link href="https://yes5144.github.io//post/mysql-zhu-cong">
        </link>
        <updated>2019-08-11T03:39:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="mariadbmysql的主从复制部署docker">MariaDB/Mysql的主从复制部署(Docker)</h3>
<pre><code>### 原文链接：https://blog.csdn.net/clearlxj/article/details/88313033

### 注意文中有一个笔误： /home/lxj/hedisql  /home/lxj/heidisql/

## 修改master_my.cnf，在 [mysqld] 节点下添加

[mysqld]
server-id=1
log_bin=master-bin
binlog-ignore-db=mysql
binlog-ignore-db=information_schema
binlog-ignore-db=performance_schema
binlog-ignore-db=test
innodb_flush_log_at_trx_commit=1
binlog_format=mixed


## 修改slave1_my.cnf，在 [mysqld] 节点下添加

[mysqld]
server-id=2
relay-log-index=slave-relay-bin.index
relay-log=slave-relay-bin
relay_log_recovery=1

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql-Docker部署mha]]></title>
        <id>https://yes5144.github.io//post/mysql-mha</id>
        <link href="https://yes5144.github.io//post/mysql-mha">
        </link>
        <updated>2019-08-11T03:23:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="docker搭建mariadbmysql-mha高可用集群">Docker搭建MariaDB/Mysql MHA高可用集群</h3>
<pre><code>原文链接：https://blog.csdn.net/clearlxj/article/details/88422206

## Checking if super_read_only is defined and turned on..DBD::mysql::st execute failed: Unknown system variable 'super_read_only' at /usr/share/perl5/vendor_perl/MHA/SlaveUtil.pm line 245.
报错原因：mha4mysql版本问题，
解决办法：最后将MHA的版本换成mha4mysql-0.56。

### mysql--docker化实践：https://blog.csdn.net/weixin_34290390/article/details/89123731
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql-GTID主从复制]]></title>
        <id>https://yes5144.github.io//post/mysql-gtid-zhu-cong</id>
        <link href="https://yes5144.github.io//post/mysql-gtid-zhu-cong">
        </link>
        <updated>2019-08-10T15:15:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基于gtid-主从复制">基于gtid 主从复制</h3>
<pre><code>参考链接：https://blog.csdn.net/weixin_43407305/article/details/87911235
参考链接：https://blog.csdn.net/martingpf/article/details/81115187
参考链接：https://blog.csdn.net/leshami/article/details/50630691
参考链接：https://blog.csdn.net/qq_43094192/article/details/83994952

MySQL 5.6引入的GTID(Global Transaction IDs)使得其复制功能的配置、监控及管理变得更加易于实现，且更加健壮.

MySQL 5.6中使用复制功能，其服务配置段[mysqld]中于少应该定义如下选项：
binlog-format：二进制日志的格式，有row、statement和mixed几种类型；需要注意的是：当设置隔离级别为READ-COMMITED必 须设置二进制日志格式为ROW，现在MySQL官方认为STATEMENT这个已经不再适合继续使用,但mixed类型在默认的事务隔离级别下，可能会导致主从数据不一致；
log-slave-updates、gtid-mode、enforce-gtid-consistency、report-port和report-host：用于启动GTID及满足附属的其它需求；
master-info-repository和relay-log-info-repository：启用此两项，可用于实现在崩溃时保证二进制及从服务器安全的功能；
sync-master-info：启用之可确保无信息丢失；
slave-paralles-workers：设定从服务器的SQL线程数；0表示关闭多线程复制功能；
binlog-checksum、master-verify-checksum和slave-sql-verify-checksum：启用复制有关的所有校验功能；
binlog-rows-query-log-events：启用之可用于在二进制日志记录事件相关的信息，可降低故障排除的复杂度；
log-bin：启用二进制日志，这是保证复制功能的基本前提；
server-id：同一个复制拓扑中的所有服务器的id号必须惟一；

GTID的概念：
1）全局事务标识：global transaction identifiers。
2）GTID是一个事务一一对应，并且全局唯一ID。
3）一个GTID在一个服务器上只执行一次，避免重复执行导致数据混乱或者主从不一致。
4）GTID用来代替传统复制方法，不再使用MASTER_LOG_FILE+MASTER_LOG_POS开启复制。而是使用MASTER_AUTO_POSTION=1的方式开始复制。
5）MySQL-5.6.5开始支持的，MySQL-5.6.10后开始完善。
6）在传统的slave端，binlog是不用开启的，但是在GTID中slave端的binlog是必须开启的，目的是记录执行过的GTID（强制）。

GTID组成：
GTID = source_id:transaction_id
source_id，用于鉴别原服务器，即mysql服务器唯一的的server_uuid，由于GTID会传递到slave，所以也可以理解为源ID。
transaction_id，为当前服务器上已提交事务的一个序列号，通常从1开始自增长的序列，一个数值对应一个事务。        
示例：          
3E11FA47-71CA-11E1-9E33-C80AA9429562:23
前面的一串为服务器的server_uuid，即3E11FA47-71CA-11E1-9E33-C80AA9429562，后面的23为transaction_id

GTID原理：
1、当一个事务在主库端执行并提交时，产生GTID，一同记录到binlog日志中。
2、binlog传输到slave,并存储到slave的relaylog后，读取这个GTID的这个值设置gtid_next变量，即告诉Slave，下一个要执行的GTID值。
3、sql线程从relay log中获取GTID，然后对比slave端的binlog是否有该GTID。
4、如果有记录，说明该GTID的事务已经执行，slave会忽略。
5、如果没有记录，slave就会执行该GTID事务，并记录该GTID到自身的binlog，
   在读取执行事务前会先检查其他session持有该GTID，确保不被重复执行。
6、在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有就用全部扫描。

一、简单主从模式配置步骤
1、配置主从节点的服务配置文件
1.1、配置master节点：
[mysqld]
binlog-format=ROW
log-bin=master-bin
log-slave-updates=true  ###从服务器更新同步二进制日志信息，适用于高可用中，从服务器升级主服务器用
gtid-mode=on 
enforce-gtid-consistency=true
master-info-repository=TABLE
relay-log-info-repository=TABLE
sync-master-info=1
slave-parallel-workers=2
binlog-checksum=CRC32
master-verify-checksum=1
slave-sql-verify-checksum=1
binlog-rows-query-log_events=1
server-id=1
report-port=3306
port=3306
datadir=/mydata/
socket=/tmp/mysql.sock
report-host=edong1

1.2、配置slave节点：
[mysqld]
binlog-format=ROW
log-slave-updates=true
gtid-mode=on 
enforce-gtid-consistency=true
master-info-repository=TABLE
relay-log-info-repository=TABLE
sync-master-info=1
slave-parallel-workers=2
binlog-checksum=CRC32
master-verify-checksum=1
slave-sql-verify-checksum=1
binlog-rows-query-log_events=1
server-id=11
report-port=3306
port=3306
log-bin=mysql-bin.log
datadir=/mydata/
socket=/tmp/mysql.sock
report-host=edong2
slave节点配置和master节点配置一样的目的：主服务器挂了，从服务器可以快速升级为主服务器
2、创建复制用户
mysql&gt;grant replication slave on *.* to 'repluser'@'192.168.0.%' identified by 'replpassword';
3、为备节点提供初始数据集
锁定主表，备份主节点上的数据，将其还原至从节点；如果没有启用GTID，在备份时需要在master上使用show master status命令查看二进制日志文件名称及事件位置，以便后面启动slave节点时使用。
4、启动从节点的复制线程
如果启用了GTID功能，则使用如下命令：
mysql&gt;change master to master_host='192.168.0.202',master_user='repluser',master_password='replpassword',master_auto_position=1;

半同步复制

1、分别在主从节点上安装相关的插件
master&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
slave&gt; INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';

2、启用半同步复制
在master上的配置文件中，添加
rpl_semi_sync_master_enabled=ON
在至少一个slave节点的配置文件中添加
rpl_semi_sync_slave_enabled=ON
而后重新启动mysql服务即可生效。

或者，也可以mysql服务上动态启动其相关功能：
master&gt; SET GLOBAL rpl_semi_sync_master_enabled = ON;
slave&gt; SET GLOBAL rpl_semi_sync_slave_enabled = ON;
slave&gt; STOP SLAVE IO_THREAD; START SLAVE IO_THREAD;

3、确认半同步功能已经启用
master&gt; CREATE DATABASE magedudb;
master&gt; SHOW STATUS LIKE 'Rpl_semi_sync_master_yes_tx';

slave&gt; SHOW DATABASES;

</code></pre>
<h3 id="主从复制">主从复制</h3>
<pre><code>主从复制过程存在三个线程，Master端的I/O线程，Slave的I/O线程与SQL线程。Master端需要开启binlog日志，Slave端需要开启relaylog。
1、Slave端的I/O读取master.info文件，获取binlog文件名和位置点，然后向Master端的I/O线程请求，该binlog文件名和位置点的binlog信息。
（master.info文件在配置主从复制时使用change master命令来指定生成）
2、Master端的I/O线程会根据Slave端的I/O线程请求的信息来读取Master的binlog日志信息与及读取到最新的binlog文件名和位置点一同返回给Slave的I/O线程。
3、Slave端的I/O线程会把获取到的binlog日志写入relaylog（中继日志）文件中，并且更新master.info文件信息。（把读取到Master最新的binlog日志文件名和位置点更新到master.info文件中，下一次当前位置去读取Master的binlog日志）
4、Slave端的SQL线程会定期读取relaylog，把二进制的日志解析成SQL语句，并执行这些SQL语句，同步数据到从库中

原文链接：https://blog.csdn.net/weixin_43407305/article/details/87911235
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[k8s 学习]]></title>
        <id>https://yes5144.github.io//post/k8s-xue-xi</id>
        <link href="https://yes5144.github.io//post/k8s-xue-xi">
        </link>
        <updated>2019-08-08T16:12:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1docker的安装">1，docker的安装</h3>
<pre><code>## 使用阿里云镜像加速安装下载docker-ce
## 参考链接：https://yq.aliyun.com/articles/110806

# step 1: 安装必要的一些系统工具
sudo yum install -y yum-utils device-mapper-persistent-data lvm2
# Step 2: 添加软件源信息
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# Step 3: 更新并安装 Docker-CE
sudo yum makecache fast
sudo yum -y install docker-ce
# Step 4: 开启Docker服务
sudo service docker start

</code></pre>
<h3 id="2配置-docker-加速器">2，配置 docker 加速器</h3>
<pre><code>## 参考链接https://www.daocloud.io/mirror
## 该脚本可以将 --registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。
curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io



</code></pre>
<h3 id="5k8s基础">5，k8s基础</h3>
<pre><code>## https://kubernetes.io/docs/tutorials/

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 解压缩命令]]></title>
        <id>https://yes5144.github.io//post/linux-jie-ya-suo-ming-ling</id>
        <link href="https://yes5144.github.io//post/linux-jie-ya-suo-ming-ling">
        </link>
        <updated>2019-08-07T23:23:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="不解压缩查看压缩包内文件列表">不解压缩，查看压缩包内文件列表</h3>
<pre><code>tar -ztvf file.tar.gz

tar.gz
tar tzvf xxx.tar.gz

tar.bz2
tar tjvf xxx.tar.bz2

zip
unzip -l xxx.zip  (简略模式)
unzip -v xxx.zip (详细模式)

rar
unrar l xxx.rar(简略模式)
unrar v xxx.rar(详细模式)

 

linux压缩和解压缩命令大全

tar命令

　　解包：tar zxvf FileName.tar

　　打包：tar czvf FileName.tar DirName

gz命令

　　解压1：gunzip FileName.gz

　　解压2：gzip -d FileName.gz

　　压缩：gzip FileName

　　.tar.gz 和 .tgz

　　解压：tar zxvf FileName.tar.gz

　　压缩：tar zcvf FileName.tar.gz DirName

   压缩多个文件：tar zcvf FileName.tar.gz DirName1 DirName2 DirName3 ...

bz2命令

　　解压1：bzip2 -d FileName.bz2

　　解压2：bunzip2 FileName.bz2

　　压缩： bzip2 -z FileName

　　.tar.bz2

　　解压：tar jxvf FileName.tar.bz2

　　压缩：tar jcvf FileName.tar.bz2 DirName

bz命令

　　解压1：bzip2 -d FileName.bz

　　解压2：bunzip2 FileName.bz

　　压缩：未知

　　.tar.bz

　　解压：tar jxvf FileName.tar.bz

Z命令

　　解压：uncompress FileName.Z

　　压缩：compress FileName

　　.tar.Z

　　解压：tar Zxvf FileName.tar.Z

　　压缩：tar Zcvf FileName.tar.Z DirName

zip命令

　　解压：unzip FileName.zip

　　压缩：zip FileName.zip DirName

rar命令

　　解压：rar a FileName.rar

　　压缩：r ar e FileName.rar
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promql 查询语法]]></title>
        <id>https://yes5144.github.io//post/promql-cha-xun-yu-fa</id>
        <link href="https://yes5144.github.io//post/promql-cha-xun-yu-fa">
        </link>
        <updated>2019-07-28T14:51:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="首先部署一套prometheus访问9090端口">首先部署一套prometheus，访问9090端口</h3>
<pre><code>https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-query-language
## 简单使用
http_requests_total{code=&quot;200&quot;,handler=&quot;alerts&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;}=(20889@1518096812.326)
http_requests_total{code=&quot;200&quot;,handler=&quot;graph&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;}=(21287@1518096812.326)

## 支持正则表达式
http_requests_total{environment=~&quot;staging|testing|development&quot;,method!=&quot;GET&quot;}

## 查询范围
http_request_total{}[5m]
http_request_total{} # 瞬时向量表达式，选择当前最新的数据
http_request_total{}[5m] # 区间向量表达式，选择以当前时间为基准，5分钟内的数据

## 聚合操作
# 查询系统所有http请求的总量
sum(http_request_total)

# 按照mode计算主机CPU的平均使用时间
avg(node_cpu) by (mode)

# 按照主机查询各个主机的CPU使用率
sum(sum(irate(node_cpu{mode!='idle'}[5m]))  / sum(irate(node_cpu[5m]))) by (instance)

# top 5
topk(5, http_requests_total)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Grafana + zabbix 打造监控大屏]]></title>
        <id>https://yes5144.github.io//post/grafana-zabbix-da-zao-jian-kong-da-ping</id>
        <link href="https://yes5144.github.io//post/grafana-zabbix-da-zao-jian-kong-da-ping">
        </link>
        <updated>2019-07-28T13:47:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="每天看着zabbix展示界面是不是有点腻歪了要不要换个高大上提升一下逼格">每天看着zabbix展示界面是不是有点腻歪了，要不要换个高大上提升一下逼格？？？</h3>
<p>参考链接：</p>
<pre><code>## 分布式监控系统Zabbix--使用Grafana进行图形展示
https://www.cnblogs.com/kevingrace/p/7108060.html
## 10分钟打造炫酷的监控大屏
http://www.ywjt.org/index.php/archives/1802
## 徒手教你制作运维监控大屏
https://www.cnblogs.com/zhangs1986/p/11180694.html
## 官方地址：http://docs.grafana-zabbix.org
## 项目Demo：http://play.grafana.org/
## 项目github：https://github.com/grafana/grafana
</code></pre>
<h3 id="当你耐心看完如上链接相信已经差不多ok了下面只是我的坑友情提示一下">当你耐心看完如上链接，相信已经差不多OK了，下面只是我的坑友情提示一下：</h3>
<h4 id="1由于本人采用的是tar包解压的方式启动所以plugins在安装目录的dataplugins你可以修改配置文件重新指向varlibgrafanaplugins">1，由于本人采用的是tar包解压的方式启动，所以plugins在安装目录的data/plugins/，你可以修改配置文件重新指向/var/lib/grafana/plugins/</h4>
<pre><code>## 获取可用插件列表
grafana-cli plugins list-remote
 
## 安装zabbix插件
grafana-cli plugins install alexanderzobnin-zabbix-app
 
## 安装插件完成之后重启garfana服务
service grafana-server restart

## 安装其他图形插件
# 饼图展示
grafana-cli plugins install grafana-piechart-panel
#钟表形展示
grafana-cli plugins install grafana-clock-panel
grafana-cli plugins install briangann-gauge-panel
#字符型展示
grafana-cli plugins install natel-discrete-panel
#服务器状态
grafana-cli plugins install vonage-status-panel
</code></pre>
<h4 id="2在grafana官网找一个zabbix插件稍稍修改应用">2，在grafana官网找一个zabbix插件，稍稍修改应用</h4>
<pre><code>https://grafana.com/grafana/dashboards/6098

</code></pre>
<h4 id="有兴趣开发一个grafana插件">有兴趣开发一个grafana插件</h4>
<p>https://juejin.im/post/5addbcbd5188256715474452</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git和Svn 差异化打包]]></title>
        <id>https://yes5144.github.io//post/git-he-svn-chai-yi-hua-da-bao</id>
        <link href="https://yes5144.github.io//post/git-he-svn-chai-yi-hua-da-bao">
        </link>
        <updated>2019-07-18T15:40:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="git">Git</h3>
<pre><code>git diff这个命令能比较两个提交之间的差异，使用–name-only参数可以只显示文件名。例如：

git diff 608e120 4abe32e --name-only

打包差异文件
git diff 608e120 4abe32e --name-only | xargs zip update.zip

备注：608e120和4abe32e为前后两个提交的commit id

原文：https://blog.csdn.net/liuxinfa/article/details/82878640 
</code></pre>
<h3 id="svn">Svn</h3>
<pre><code>最近接手一个PHP项目，修复GUG和优化功能，由于是已经在用的项目，并且诸如附件上传都是保存到WEB目录下的，

所以不宜采用全量部署的方式来更新软件，最好用增量部署来更新服务器的WEB目录。

程序代码采用SVN管理，在主干上开发，每次部署都建一个tag，这样通过比较tag和主干的差别就可以知道有哪些文件发生了变动。具体的命令格式是： 

svn diff --summarize http://rep_url/tags/proj1_090214 http://rep_url/trunk/proj1 &gt;diff.txt

这个命令比较了 proj1_090214 和 proj1 的差异，并将差异信息输出到文件 diff.txt
summarize  选项的含义是只显示结果的概要，不显示文件的具体差异。

有了diff.txt，就可以知道需要部署哪些文件了，感觉很方便

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[沉迷学习]]></title>
        <id>https://yes5144.github.io//post/chen-mi-xue-xi</id>
        <link href="https://yes5144.github.io//post/chen-mi-xue-xi">
        </link>
        <updated>2019-07-18T01:00:32.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Python</li>
<li>Django</li>
<li>Golang</li>
<li>Beego</li>
<li>Docker</li>
<li>K8s</li>
<li>Linux架构师</li>
<li>chinaielts</li>
</ul>
<pre><code>## python
https://github.com/jackfrued/Python-100-Days

## k8s
https://github.com/opsnull/follow-me-install-kubernetes-cluster

## beego
https://www.jianshu.com/nb/27703855
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go 开发环境部署]]></title>
        <id>https://yes5144.github.io//post/go-kai-fa-huan-jing-bu-shu</id>
        <link href="https://yes5144.github.io//post/go-kai-fa-huan-jing-bu-shu">
        </link>
        <updated>2019-07-16T15:14:03.000Z</updated>
        <content type="html"><![CDATA[<h4 id="依赖包在golangorg">依赖包在golang.org ???</h4>
<pre><code>git clone https://github.com/golang/net.git $GOPATH/src/github.com/golang/net
git clone https://github.com/golang/sys.git $GOPATH/src/github.com/golang/sys
git clone https://github.com/golang/tools.git $GOPATH/src/github.com/golang/tools
git clone https://github.com/golang/sync.git $GOPATH/src/github.com/golang/sync
git clone https://github.com/golang/lint.git $GOPATH/src/github.com/golang/lint
git clone https://github.com/golang/text.git $GOPATH/src/github.com/golang/text

mkdir -p  $GOPATH/src/golang.org/x
cp -a $GOPATH/src/github.com/golang/  $GOPATH/src/golang.org/x

go get -v github.com/rogpeppe/godef
go get -v github.com/mdempsky/gocode
go get -v github.com/stamblerre/gocode
go get -v golang.org/x/tools/cmd/goimports
go get -v github.com/ramya-rao-a/go-outline
go get -v golang.org/x/tools/cmd/gopls
go get -u github.com/spf13/cobra/cobra

</code></pre>
<h4 id="vscode-go代码补全">vscode go代码补全</h4>
<pre><code>https://maiyang.me/post/2018-09-14-tips-vscode/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 请空表]]></title>
        <id>https://yes5144.github.io//post/mysql-qing-kong-biao</id>
        <link href="https://yes5144.github.io//post/mysql-qing-kong-biao">
        </link>
        <updated>2019-07-15T15:31:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code>SET FOREIGN_KEY_CHECKS = 0;
TRUNCATE `events`;
TRUNCATE `problem`;

set FOREIGN_key_checks =1;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prometheus 入门]]></title>
        <id>https://yes5144.github.io//post/prometheus-ru-men</id>
        <link href="https://yes5144.github.io//post/prometheus-ru-men">
        </link>
        <updated>2019-07-13T11:32:15.000Z</updated>
        <content type="html"><![CDATA[<p>prometheus</p>
<p>promOL</p>
<pre><code>http_requests_total[5m]
rate(http_requests_total[5m])


http_request_duration_microseconds_count{handler=&quot;query&quot;}
</code></pre>
<h4 id="这里提供一些其他常用的表示式">这里提供一些其他常用的表示式：</h4>
<pre><code>查询主机使用率

1 - avg by (agentIP) (irate(node_cpu{agentIP=~&quot;$machine&quot;, mode=&quot;idle&quot;}[5m]))
查询主机磁盘IO

irate(node_disk_io_time_ms{agentIP=~'$machine',device!~'^(md\\d+$|dm-)'}[5m])
查询主机内存使用量

(node_memory_MemTotal{agentIP=&quot;101.37.26.244&quot;} - node_memory_MemAvailable{agentIP=&quot;101.37.26.244&quot;}) / node_memory_MemTotal{agentIP=&quot;101.37.26.244&quot;}
除了本文中示例的表达式功能以外，Prometheus还提供了其它丰富的查询，操作符以及表达式。包括：运算符，聚合,函数等等。

http://ylzheng.com/2018/01/17/prometheus-sd-and-relabel/


通过指标io_namespace_http_requests_total我们可以：

查询应用的请求总量
# PromQL
sum(io_namespace_http_requests_total)


查询每秒Http请求量
# PromQL
sum(rate(io_wise2c_gateway_requests_total[5m]))


查询当前应用请求量Top N的URI
# PromQL
topk(10, sum(io_namespace_http_requests_total) by (path))

事件发生总的次数
# 含义：当前http请求发生总次数为12次
io_namespace_http_requests_latency_seconds_summary_count{path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,} 12.0
事件产生的值的总和
# 含义：这12次http请求的总响应时间为 51.029495508s
io_namespace_http_requests_latency_seconds_summary_sum{path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,} 51.029495508
事件产生的值的分布情况
# 含义：这12次http请求响应时间的中位数是3.052404983s
io_namespace_http_requests_latency_seconds_summary{path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,quantile=&quot;0.5&quot;,} 3.052404983
# 含义：这12次http请求响应时间的9分位数是8.003261666s
io_namespace_http_requests_latency_seconds_summary{path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,quantile=&quot;0.9&quot;,} 8.003261666
使用Collector暴露业务指标

http://ylzheng.com/2018/03/12/prometheus-alertmanager-ha/

https://learnku.com/articles/22193#098370

https://songjiayang.gitbooks.io/prometheus/content/

https://tizeen.github.io/2018/04/21/prometheus+node_exporter+alertmanager%E7%9B%91%E6%8E%A7%E4%B8%BB%E6%9C%BA%E5%AE%9E%E8%B7%B5/

https://www.cnblogs.com/fairjm/p/start_prometheus.html

https://www.ctolib.com/docs/sfile/prometheus-book/sd/service-discovery-with-consul.html
https://blog.csdn.net/polo2044/article/details/83963211

http://docs.flycloud.me/docs/ELKStack/elasticsearch/other/grafana.html

https://blog.52itstyle.vip/archives/2049/

https://juejin.im/entry/5bc411245188255c5721663a
</code></pre>
<h4 id="grafana-命令行操作">grafana 命令行操作</h4>
<pre><code>列出可用的插件
#grafana-cli plugins list-remote
 
安装最新版本的插件
#grafana-cli plugins install &lt;plugin-id&gt;
 
安装特定版本的插件
#grafana-cli plugins install &lt;plugin-id&gt; &lt;version&gt;
 
列出安装的插件
#grafana-cli plugins ls
 
更新所有安装的插件
#grafana-cli plugins update-all
 
更新一个插件
#grafana-cli plugins update &lt;plugin-id&gt;
 
删除一个插件
#grafana-cli plugins remove &lt;plugin-id&gt;

https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-node-exporter

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pycharm 常用设置]]></title>
        <id>https://yes5144.github.io//post/pycharm-chang-yong-she-zhi</id>
        <link href="https://yes5144.github.io//post/pycharm-chang-yong-she-zhi">
        </link>
        <updated>2019-07-13T11:30:47.000Z</updated>
        <content type="html"><![CDATA[<h4 id="pycharm使用文档">pycharm使用文档</h4>
<pre><code>1 为项目配置Python解释器
	File &gt; Settings &gt; Project:项目名称 &gt; Project Interpreter 这里可以选择各种解释器
	
2 创建Python文件
	- 创建Python file
	- 创建package 这说明是可以当做Python模块导出的？
	
3 安装第三方模块
	Project:项目名称 &gt; Project Interpreter &gt; 绿色+号，搜索你想要安装的模块 &gt; Install Package
	
4 常用设置（外观、界面）
	- 菜单字体及大小
		File &gt; Settings &gt; Appearance &amp; Behavior &gt; Overrode default fonts
	- Console 和Terminal字体大小
		Editor &gt; Colors &amp; Font &gt; Console Font
	- 设置文件编码
		Editor &gt; File Encodings
	- 修改背景颜色
		Editor &gt; Colors &amp; Font &gt; General
	- tab=4个空格
		Editor &gt; Code Style &gt; Python
	- 字体颜色
		Editor &gt; Colors &amp; Font &gt; Python
	- 关闭自动更新
	    Appearance &amp; Behavior &gt; System Settings &gt; Updates
	- 脚本头设置
		Editor &gt; File and Code Templates &gt; Python Script
		自动日期：Date: ${DATE}
		光标位置：#[[$END$]]# 并且勾选Enable Live Templates
	- 显示行号
		Editor &gt; General &gt; Appearance &gt; 勾选Show line numbers
	- 导入导出pycharm自定义的配置
		File &gt; Export Settings(导出)/ Import Settings(导入)
		
5 常用快捷键、如复制当前行、删除当前行、批量注释、缩进、查找和替换
	- 快捷键的查询和配置：Keymap
		快速换行： Ctrl + Enter
		快速查找： Ctrl + F
        替换： Ctrl + H
        折叠代码块：Ctrl + -
        删除当前行：Ctrl + E	
	- 滚轮放大缩小代码
	    Settings &gt; 搜索font &gt; Decrease Font Size / Increase Font Size

6 pycharm 安装插件
	Settings &gt; Plugins &gt; Browse repositories(中间那个) &gt; 搜索插件 &gt; install
	常用插件：
		- Markdown support
		- .ignore
		- BashSuport
		- IdeaVim
		- CodeGlance

7 Git配置
	- 安装好git
	- Settings &gt; Version Control &gt; Git
	
	
	pycharm快捷键及一些常用设置

1、编辑（Editing）

Ctrl + Space 基本的代码完成（类、方法、属性）
Ctrl + Alt + Space 快速导入任意类
Ctrl + Shift + Enter 语句完成
Ctrl + P 参数信息（在方法中调用参数）
Ctrl + Q 快速查看文档
Shift + F1 外部文档
Ctrl + 鼠标 简介
Ctrl + F1 显示错误描述或警告信息
Alt + Insert 自动生成代码
Ctrl + O 重新方法
Ctrl + Alt + T 选中
Ctrl + / 行注释
Ctrl + Shift + / 块注释
Ctrl + W 选中增加的代码块
Ctrl + Shift + W 回到之前状态
Ctrl + Shift + ]/[ 选定代码块结束、开始
Alt + Enter 快速修正
Ctrl + Alt + L 代码格式化
Ctrl + Alt + O 优化导入
Ctrl + Alt + I 自动缩进
Tab / Shift + Tab 缩进、不缩进当前行
Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板
Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板
Ctrl+V/Shift+Insert 从剪贴板粘贴
Ctrl + Shift + V 从最近的缓冲区粘贴
Ctrl + D 复制选定的区域或行
Ctrl + Y 删除选定的行
Ctrl + Shift + J 添加智能线
Ctrl + Enter 智能线切割
Shift + Enter 另起一行
Ctrl + Shift + U 在选定的区域或代码块间切换
Ctrl + Delete 删除到字符结束
Ctrl + Backspace 删除到字符开始
Ctrl + Numpad+/- 展开折叠代码块
Ctrl + Numpad+ 全部展开
Ctrl + Numpad- 全部折叠
Ctrl + F4 关闭运行的选项卡

2、查找/替换(Search/Replace)
F3 下一个
Shift + F3 前一个
Ctrl + R 替换
Ctrl + Shift + F 全局查找
Ctrl + Shift + R 全局替换

3、运行(Running)
Alt + Shift + F10 运行模式配置
Alt + Shift + F9 调试模式配置
Shift + F10 运行
Shift + F9 调试
Ctrl + Shift + F10 运行编辑器配置
Ctrl + Alt + R 运行manage.py任务

4、调试(Debugging)
F8 跳过
F7 进入
Shift + F8 退出
Alt + F9 运行游标
Alt + F8 验证表达式
Ctrl + Alt + F8 快速验证表达式
F9 恢复程序
Ctrl + F8 断点开关
Ctrl + Shift + F8 查看断点

5、导航(Navigation)
Ctrl + N 跳转到类
Ctrl + Shift + N 跳转到符号
Alt + Right/Left 跳转到下一个、前一个编辑的选项卡
F12 回到先前的工具窗口
Esc 从工具窗口回到编辑窗口
Shift + Esc 隐藏运行的、最近运行的窗口
Ctrl + Shift + F4 关闭主动运行的选项卡
Ctrl + G 查看当前行号、字符号
Ctrl + E 当前文件弹出
Ctrl+Alt+Left/Right 后退、前进
Ctrl+Shift+Backspace 导航到最近编辑区域
Alt + F1 查找当前文件或标识
Ctrl+B / Ctrl+Click 跳转到声明
Ctrl + Alt + B 跳转到实现
Ctrl + Shift + I查看快速定义
Ctrl + Shift + B跳转到类型声明
Ctrl + U跳转到父方法、父类
Alt + Up/Down跳转到上一个、下一个方法
Ctrl + ]/[跳转到代码块结束、开始
Ctrl + F12弹出文件结构
Ctrl + H类型层次结构
Ctrl + Shift + H方法层次结构
Ctrl + Alt + H调用层次结构
F2 / Shift + F2下一条、前一条高亮的错误
F4 / Ctrl + Enter编辑资源、查看资源
Alt + Home显示导航条F11书签开关
Ctrl + Shift + F11书签助记开关
Ctrl + #[0-9]跳转到标识的书签
Shift + F11显示书签

6、搜索相关(Usage Search)
Alt + F7/Ctrl + F7文件中查询用法
Ctrl + Shift + F7文件中用法高亮显示
Ctrl + Alt + F7显示用法

7、重构(Refactoring)
F5复制F6剪切
Alt + Delete安全删除
Shift + F6重命名
Ctrl + F6更改签名
Ctrl + Alt + N内联
Ctrl + Alt + M提取方法
Ctrl + Alt + V提取属性
Ctrl + Alt + F提取字段
Ctrl + Alt + C提取常量
Ctrl + Alt + P提取参数

8、控制VCS/Local History
Ctrl + K提交项目
Ctrl + T更新项目
Alt + Shift + C查看最近的变化
Alt + BackQuote(’)VCS快速弹出

9、模版(Live Templates)
Ctrl + Alt + J当前行使用模版
Ctrl +Ｊ插入模版

10、基本(General)
Alt + #[0-9]打开相应的工具窗口
Ctrl + Alt + Y同步
Ctrl + Shift + F12最大化编辑开关
Alt + Shift + F添加到最喜欢
Alt + Shift + I根据配置检查当前文件
Ctrl + BackQuote(’)快速切换当前计划
Ctrl + Alt + S　打开设置页
Ctrl + Shift + A查找编辑器里所有的动作
Ctrl + Tab在窗口间进行切换

一些常用设置：

1. pycharm默认是自动保存的，习惯自己按ctrl + s 的可以进行如下设置：
1. file -&gt; Setting -&gt; General -&gt; Synchronization -&gt; Save files on frame deactivation 和 Save files automatically if application is idle for .. sec 的勾去掉
2. file -&gt;Setting -&gt; Editor -&gt; Editor Tabs -&gt; Mark modified tabs with asterisk 打上勾
2. Alt + Enter: 自动添加包

3. 对于常用的快捷键，可以设置为visual studio(eclipse...)一样的：
file -&gt; Setting -&gt; Keymap -&gt; Keymaps -&gt; vuisual studio -&gt; Apply

4. Pycharm中默认是不能用Ctrl+滚轮改变字体大小的，可以在file -&gt; Setting -&gt;Editor-〉Mouse中设置

5. 要设置Pycharm的字体，要先在file -&gt; Setting -&gt;Editor-〉Editor中选择一种风格并保存，然后才可以改变

6. 在setting中搜索theme可以改变主题，所有配色统一改变
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Anaconda 使用入门]]></title>
        <id>https://yes5144.github.io//post/anaca</id>
        <link href="https://yes5144.github.io//post/anaca">
        </link>
        <updated>2019-07-13T11:27:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="anacona3">Anacona3</h2>
<p><a href="https://www.anaconda.com/download/">Anaconda官网</a></p>
<h3 id="创建一个新的-environment">创建一个新的 environment</h3>
<p>conda create --name python34 python=3.4</p>
<h3 id="查看已经存在的environment">查看已经存在的environment</h3>
<p>conda info -e</p>
<h3 id="激活一个-environment">激活一个 environment</h3>
<p>activate python34  # for windows
source activate python34  # for linux &amp; mac</p>
<h3 id="退出一个-environment">退出一个 environment</h3>
<p>deactivate python34 # for windows
source deactivate python34  # for linux</p>
<h3 id="删除一个-environment">删除一个 environment</h3>
<p>conda remove --name python34 --all</p>
<h3 id="conda-的包管理有点类似pip">conda 的包管理有点类似pip</h3>
<p>conda install numpy</p>
<h3 id="查看已经安装的python包">查看已经安装的Python包</h3>
<p>conda list
conda list -n python34  # 查看指定环境安装的Python包</p>
<h3 id="删除一个-python包">删除一个 Python包</h3>
<p>conda remove -n python34 numpy</p>
<h2 id="anaconda换源">anaconda换源：</h2>
<h4 id="指定清华的源">指定清华的源：</h4>
<p>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</p>
<h4 id="有资源显示源地址">有资源显示源地址：</h4>
<p>conda config --set show_channel_urls yes</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shell 编程]]></title>
        <id>https://yes5144.github.io//post/shell-bian-cheng</id>
        <link href="https://yes5144.github.io//post/shell-bian-cheng">
        </link>
        <updated>2019-07-13T03:14:47.000Z</updated>
        <content type="html"><![CDATA[<p>没有必要再去争论什么语言的优劣，一门语言只要存活下来，就一定有它的优势所在。
世界上只有烂代码，没有烂语言。还是那句话，语言没有三六九等之分，只有合适与否之别。什么是合适？合适就是性价比最好、综合得分最高的那个。</p>
<h4 id="1-shift位移">1. shift位移</h4>
<pre><code>cat  shift.sh

#!/bin/bash
loop=`expr $(echo $#) / 2`
for i in $(seq 1 $loop)
do 
  echo $1 $2
	shift 2
done
## 如果传递的参数不是偶数，最后一位将被丢弃
</code></pre>
<h4 id="文本三剑客">文本三剑客</h4>
<pre><code>## grep
grep  -c  processor  /proc/cpuinfo
grep  -c  ^root  /etc/passwd*

grep  -i ^port  /etc/ssh/sshd_config

grep  -C1 ^Port  /etc/ssh/sshd_config
grep  -B1 ^Port  /etc/ssh/sshd_config
grep  -A1 ^Port  /etc/ssh/sshd_config

grep  -l ^root /etc/*  ## 显示文件

## 包含于排除
--include=GLOB;
--exclude=GLOB;
--exclude-from=FILE;
--exclude-dir=DIR;

grep  -l  ^root  --exclude=*-  /etc/*
</code></pre>
<pre><code>## sed
sed  -i.bak  EDIT-COMMAND  INPUT-FILE

[Address]s/Pattern/Replacement/FLAGs

sed  &quot;3s/bird/cat/2&quot;  text
sed  &quot;1,3s/bird/cat/g&quot;  text
sed  &quot;/work/s/bird/cat/&quot;  text
sed  &quot;/work/,/push/s/bird/cat/g&quot;  text

sed  &quot;3i\cat&quot;  text
sed  &quot;3a\cat&quot;  text
sed  &quot;3c\cat&quot;  text
sed  &quot;3d&quot;  text
sed  &quot;3r /root/text2&quot;  text  ## 在第三行下方将另一个文件text2的内容追加进去

sed  &quot;3s/.*/cat &amp;/&quot;  text
sed  &quot;3s/.*/&amp; cat/&quot;  text
</code></pre>
<pre><code>## awk
## 统计
awk  /git/  /etc/shadow

awk  '/git/{n++} END {print n}'  /etc/shadow

## 获取某一列
ps -C  qemu-kvm
ps -C  qemu-kvm |awk '{if (NR==6) print $0}'

## 比较
awk  'BEGIN{a=2;b=10;print (a&gt;b)?1:0}'
awk  'BEGIN{a=&quot;2&quot;;b=&quot;10&quot;;print (a&gt;b)?1:0}'
awk  'BEGIN{a=&quot;2&quot;;b=&quot;1&quot;;print (a&gt;b)?1:0}'

## 求和
ls -l |awk '!/total/ {sum+=$5;line+=1} END {printf &quot;Sum = %d\nLines = %d\nAverage = %d\n&quot;, sum, line,sum/line}'

## 求最值
ls -l |awk '!/total/ {if(min==&quot;&quot;) min=$5; if ($5&lt;min) min=$5} END {print min}'

ls -l |awk '!/total/ {if(max==&quot;&quot;) max=$5; if ($5&gt;max) max=$5} END {print max}'

## 替换
df -Ph  ## 选项-P表示输出结果遵守POSIX标准，一行一个条目

df -Ph |awk '!/Filesystem/ {sub(&quot;%&quot;,&quot;&quot;,$5); if ($5&gt;10) print}'
## sub替换函数看上去不太优雅，百分号被删除了。但是我们还可以使用+0方式做些改进
df -Ph |awk '!/Filesystem/  {if ($5+0&gt;10) print}'

</code></pre>
<h4 id="ip地址排序">ip地址排序</h4>
<pre><code>cat  ip |sort -n -t. -k1,1 -k2,2 -k3,3 -k4,4
</code></pre>
<p>做事有四种态度
做牛马--把工作当负担，糊弄着做。
做任务--把工作当差事，尽职做。
做产品--把工作当做市场价值，用心去做。
做品牌--把工作当做文化传承，注魂去做。</p>
<p>不得罪人的SE，不是一个好的SE。--坚守红线
只有优秀的SE，没有合格的SE。--精益求精</p>
]]></content>
    </entry>
</feed>